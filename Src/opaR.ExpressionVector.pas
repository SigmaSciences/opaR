unit opaR.ExpressionVector;

{-------------------------------------------------------------------------------

opaR: object pascal for R

Copyright (C) 2015-2016 Sigma Sciences Ltd.

Originator: Robert L S Devine

Unless you have received this program directly from Sigma Sciences Ltd under
the terms of a commercial license agreement, then this program is licensed
to you under the terms of version 3 of the GNU Affero General Public License.
Please refer to the AGPL licence document at:
http://www.gnu.org/licenses/agpl-3.0.txt for more details.

This program is distributed WITHOUT ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING
THOSE OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

-------------------------------------------------------------------------------}

{-------------------------------------------------------------------------------

TExpressionVector is a wrapper around the SEXPREC generated by the R_ParseVector
function. This contrasts with other vector types which are wrappers for R
vectors generated by Rf_allocVector.

-------------------------------------------------------------------------------}

interface

uses
  opaR.Utils,
  opaR.ProtectedPointer,
  opaR.SEXPREC,
  opaR.Vector,
  opaR.Interfaces,
  opaR.Expression;

type
  TExpressionVector = class(TRObjectVector<IExpression>, IExpressionVector)
  protected
    function GetDataSize: integer; override;
    function ConvertPSEXPRECToValue(const aValue: PSEXPREC): IExpression; override;
    function ConvertValueToPSEXPREC(const aValue: IExpression): PSEXPREC; override;
  public
    constructor Create(const engine: IREngine; pExpr: PSEXPREC);
  end;

implementation

uses
  opaR.EngineExtension;

{ TExpressionVector }

//------------------------------------------------------------------------------
constructor TExpressionVector.Create(const engine: IREngine; pExpr: PSEXPREC);
begin
  inherited Create(engine, pExpr);
end;

function TExpressionVector.ConvertPSEXPRECToValue(const aValue: PSEXPREC):
    IExpression;
begin
  // -- Lifetime management of the returned TExpression is the
  // -- responsibility of the calling code.
  if (aValue = nil) or (aValue = TEngineExtension(Engine).NilValue) then
    result := nil
  else
    result := TExpression.Create(Engine, aValue);
end;

function TExpressionVector.ConvertValueToPSEXPREC(const aValue: IExpression):
    PSEXPREC;
begin
  if aValue = nil then
    result := TEngineExtension(Engine).NilValue
  else
    result := aValue.Handle;
end;
//------------------------------------------------------------------------------
function TExpressionVector.GetDataSize: integer;
begin
  result := SizeOf(PSEXPREC);
end;

end.
